{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pyVPT2 Docs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"api/","title":"Api","text":"<p>Performs vibrational pertubration theory calculation</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>VPTInput</code> <p>Input schema</p> required <p>Returns:</p> Type Description <code>VPTResult</code> <p>VPT2 results schema</p> Source code in <code>pyvpt2/vpt2.py</code> <pre><code>def vpt2_from_schema(inp: VPTInput) -&gt; VPTResult:\n    \"\"\"\n    Performs vibrational pertubration theory calculation\n\n    Parameters\n    ----------\n    inp: VPInput\n        Input schema\n\n    Returns\n    -------\n    VPTResult\n        VPT2 results schema\n    \"\"\"\n\n    from qcelemental.models.molecule import Molecule\n\n    if isinstance(inp, dict):\n        inp = VPTInput(**inp)\n    elif isinstance(inp, VPTInput):\n        inp = inp.copy()\n    else:\n        raise AssertionError(\"Input type not recognized.\")\n\n\n    mol = inp.molecule\n    kwargs = process_options_keywords(**inp.keywords)\n    qc_specification = inp.input_specification[0]\n    if len(inp.input_specification) == 1:\n        qc_specification2 = inp.input_specification[0]\n    else:\n        qc_specification2 = inp.input_specification[1]\n        kwargs.update({\"MULTILEVEL\": True})\n\n    mol = mol.orient_molecule()\n    mol = mol.dict()\n    mol.update({\"fix_com\": True, \"fix_orientation\": True})\n    mol = Molecule(**mol)\n    #rotor_type = check_rotor(mol)\n\n    plan = hessian_planner(mol, qc_specification, **kwargs)\n\n    if kwargs.get(\"RETURN_PLAN\", False):\n        return plan\n    else:\n        with psi4.p4util.hold_options_state():\n            plan.compute()\n        harmonic_result = plan.get_results()\n\n    plan = vpt2_from_harmonic(harmonic_result, qc_specification2, **kwargs)\n    plan.compute()\n    quartic_result = plan.get_results()\n    result_dict = process_vpt2(quartic_result, **kwargs)\n\n    return result_dict\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>pyvpt2 is a python module for calculating anharmonic vibrational frequencies using second-order vibrational perturbation theory (VPT2). Harmonic frequencies and cubic/quartic force constants are calculated using psi4 as a quantum chemistry backend.</p> <p>Example input: <pre><code>import qcelemental as qcel\nimport pyvpt2\n\nmol = qcel.models.Molecule.from_data(\"\"\"\nO   0.0   0.0         -0.12126642\nH   0.0  -1.42495308   0.96229308\nH   0.0   1.42495308   0.96229308\n\"\"\") \n\n# set method here\nqc_model = {\"method\": \"scf\",\n         \"basis\": \"6-31g*\"}\n\n# set qc level options here\nqc_kwargs = {\"d_convergence\": 1e-10,\n            \"e_convergence\": 1e-10,\n            }\n\n# set vpt2 level options here\noptions = {\"FD\": 'HESSIAN',\n            \"DISP_SIZE\": 0.05,\n            \"QC_PROGRAM\": \"psi4\",\n            }\n\ninp = {\"molecule\": mol,\n        \"input_specification\": [{\"model\": qc_model,\n                                \"keywords\": qc_kwargs}],\n        \"keywords\": options}\n\nresults = pyvpt2.vpt2_from_schema(inp)\n</code></pre></p> <p>pyVPT2 accepts QCSchema specification of the input molecule (<code>\"molecule\"</code>) and quantum chemistry model specification (<code>\"input_specification\"</code>). pyVPT2 specific options are specified with the <code>\"keywords\"</code> section. Details on specifying molecular geometries can be found in the QCElemental documentation. Molecular geometries should be tightly converged before frequency analysis. Choices for QCEngine intregrated geometry optimizers include optking and geomeTRIC. Choices for QCEngine supported quantum chemistry programs can be found here. It is very important to note that finite-difference calculations require tightly converged energies for numerical stability. It is highly advised to specify tight convergence criteria in the QC program keywords.</p>"},{"location":"tutorial/#options-list","title":"Options list:","text":"<ul> <li><code>DISP_SIZE</code> (Default: 0.05) Displacement size used in finite-difference calculations.</li> <li><code>FD</code> (Default: \"HESSIAN\") Level of finite-difference calculation. Choose highest analytical derivative available for chosen method. Options: \"ENERGY\", \"GRADIENT\", or \"HESSIAN\"   </li> <li><code>FERMI</code> (Default: True) Deperturb Fermi resonances?</li> <li><code>GVPT2</code> (Default: False) Diagonalize Fermi resonances? Requires <code>FERMI</code> to be enabled.</li> <li><code>FERMI_OMEGA_THRESH</code> (Default: 200) Frequency difference threshold below which to deperturb resonances.</li> <li><code>FERMI_K_THRESH</code> (Default: 1) Coupling threshold above which to depertub resonances.</li> <li><code>RETURN_PLAN</code> (Default: False) Return a plan of tasks to be sent to a QCPortal client?</li> <li><code>VPT2_OMEGA_THRESH</code> (Default: 1) Frequency below which to omit from VPT2 treatment`</li> <li><code>QC_PROGRAM</code> (Default: \"psi4\") QC program to run </li> <li><code>MULTILEVEL</code> (Default: False) Use different levels of theory for harmonic and anharmonic portions</li> <li><code>TASK_CONFIG</code> qcengine task configuration settings</li> </ul>"}]}