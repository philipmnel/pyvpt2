{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pyVPT2 Docs","text":"<p>pyVPT2 is a python package to calculate anharmonic vibrational frequencies of molecules using QCEngine.</p> <p>Code is available on github</p>"},{"location":"#installation","title":"Installation","text":"<p>Clone repo from gh link above and <code>pip install .</code></p>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li><code>psi4</code></li> <li><code>qcengine</code></li> <li><code>pydantic &lt; 2.0</code></li> </ul>"},{"location":"#index","title":"Index","text":"<ul> <li>Tutorial and Usage</li> <li>API Reference</li> </ul>"},{"location":"api/","title":"Api","text":"<p>Performs vibrational pertubration theory calculation</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>VPTInput</code> <p>Input schema</p> required <p>Returns:</p> Type Description <code>VPTResult</code> <p>VPT2 results schema</p> Source code in <code>pyvpt2/vpt2.py</code> <pre><code>def vpt2_from_schema(inp: VPTInput) -&gt; VPTResult:\n    \"\"\"\n    Performs vibrational pertubration theory calculation\n\n    Parameters\n    ----------\n    inp: VPInput\n        Input schema\n\n    Returns\n    -------\n    VPTResult\n        VPT2 results schema\n    \"\"\"\n\n    from qcelemental.models.molecule import Molecule\n\n    if isinstance(inp, dict):\n        inp = VPTInput(**inp)\n    elif isinstance(inp, VPTInput):\n        inp = inp.copy()\n    else:\n        raise AssertionError(\"Input type not recognized.\")\n\n\n    mol = inp.molecule\n    kwargs = process_options_keywords(**inp.keywords)\n    qc_specification = inp.input_specification[0]\n    if len(inp.input_specification) == 1:\n        qc_specification2 = inp.input_specification[0]\n    else:\n        qc_specification2 = inp.input_specification[1]\n        kwargs.update({\"MULTILEVEL\": True})\n\n    mol = mol.orient_molecule()\n    mol = mol.dict()\n    mol.update({\"fix_com\": True, \"fix_orientation\": True})\n    mol = Molecule(**mol)\n    #rotor_type = check_rotor(mol)\n\n    plan = hessian_planner(mol, qc_specification, **kwargs)\n\n    if kwargs.get(\"RETURN_PLAN\", False):\n        return plan\n    else:\n        with psi4.p4util.hold_options_state():\n            plan.compute()\n        harmonic_result = plan.get_results()\n\n    plan = vpt2_from_harmonic(harmonic_result, qc_specification2, **kwargs)\n    plan.compute()\n    quartic_result = plan.get_results()\n    result_dict = process_vpt2(quartic_result, **kwargs)\n\n    return result_dict\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#basic-example","title":"Basic Example","text":"<p>pyvpt2 is a python module for calculating anharmonic vibrational frequencies using second-order vibrational perturbation theory (VPT2). Harmonic frequencies and cubic/quartic force constants are calculated using psi4 as a quantum chemistry backend.</p> <p>Example input: <pre><code>import qcelemental as qcel\nimport pyvpt2\n\nmol = qcel.models.Molecule.from_data(\"\"\"\nO   0.0   0.0         -0.12126642\nH   0.0  -1.42495308   0.96229308\nH   0.0   1.42495308   0.96229308\n\"\"\") \n\n# set method here\nqc_model = {\"method\": \"scf\",\n         \"basis\": \"6-31g*\"}\n\n# set qc level options here\nqc_kwargs = {\"d_convergence\": 1e-10,\n            \"e_convergence\": 1e-10,\n            }\n\n# set vpt2 level options here\noptions = {\"FD\": 'HESSIAN',\n            \"DISP_SIZE\": 0.05,\n            \"QC_PROGRAM\": \"psi4\",\n            }\n\ninp = {\"molecule\": mol,\n        \"input_specification\": [{\"model\": qc_model,\n                                \"keywords\": qc_kwargs}],\n        \"keywords\": options}\n\nresults = pyvpt2.vpt2_from_schema(inp)\n</code></pre></p> <p>pyVPT2 accepts QCSchema specification of the input molecule (<code>\"molecule\"</code>) and quantum chemistry model specification (<code>\"input_specification\"</code>). pyVPT2 specific options are specified with the <code>\"keywords\"</code> section. Details on specifying molecular geometries can be found in the QCElemental documentation. Molecular geometries should be tightly converged before frequency analysis. Choices for QCEngine intregrated geometry optimizers include optking and geomeTRIC. Choices for QCEngine supported quantum chemistry programs can be found here. It is very important to note that finite-difference calculations require tightly converged energies for numerical stability. It is highly advised to specify tight convergence criteria in the QC program keywords.</p>"},{"location":"tutorial/#multilevel-computations","title":"Multilevel Computations","text":"<p>Because of the high cost of calculating the third and fourth derivatives required for VPT2, it is common to compute the anharmonic frequencies at a cheaper level of theory than the harmonic portion.  It is advantageous to compute the anharmonic portion at the high-level geometry. pyVPT2 can combine the harmonic and anharmonic portions at different levels of theory using the <code>MULTILEVEL</code> keyword, passing the different methods as list in <code>input_specification</code>.</p> <p>Example input: <pre><code>import qcelemental as qcel\nimport pyvpt2\n\nmol = qcel.models.Molecule.from_data(\"\"\"\nO   0.0   0.0         -0.12126642\nH   0.0  -1.42495308   0.96229308\nH   0.0   1.42495308   0.96229308\n\"\"\") \n\n# set high-level method here\nqc_model1 = {\"method\": \"ccsd(t)\",\n         \"basis\": \"cc-pvtz\"}\n\n# set low-level method here\nqc_model2 = {\"method\": \"mp2\",\n         \"basis\": \"cc-pvtz\"}\n\n# set qc level options here\nqc_kwargs = {\"d_convergence\": 1e-10,\n            \"e_convergence\": 1e-10,\n            }\n\n# set vpt2 level options here\noptions = {\"FD\": 'HESSIAN',\n            \"DISP_SIZE\": 0.05,\n            \"QC_PROGRAM\": \"psi4\",\n            \"MULTILEVEL\": True,\n            }\n\ninp = {\"molecule\": mol,\n        \"input_specification\": [{\"model\": qc_model1,\n                                \"keywords\": qc_kwargs},\n                                {\"model\": qc_model2,\n                                \"keywords\": qc_kwargs}],\n        \"keywords\": options}\n\nresults = pyvpt2.vpt2_from_schema(inp)\n</code></pre></p>"},{"location":"tutorial/#distributed-computations-with-qcfractal-integration","title":"Distributed Computations with QCFractal Integration","text":"<p>If QCFractal is installed, one can distribute the finite-difference steps to a QCFractal server by enabling the <code>RETURN_PLAN</code> keyword.  For example: <pre><code>import qcelemental as qcel\nimport pyvpt2\nfrom qcportal import PortalClient\n\nclient = PortalClient(\"https://[my qcfractal server here]\")\n\nmol = qcel.models.Molecule.from_data(\"\"\"\nO   0.0   0.0         -0.12126642\nH   0.0  -1.42495308   0.96229308\nH   0.0   1.42495308   0.96229308\n\"\"\") \n\n# set high-level method here\nqc_model1 = {\"method\": \"ccsd(t)\",\n         \"basis\": \"cc-pvtz\"}\n\n# set low-level method here\nqc_model2 = {\"method\": \"mp2\",\n         \"basis\": \"cc-pvtz\"}\n\n# set qc level options here\nqc_kwargs = {\"d_convergence\": 1e-10,\n            \"e_convergence\": 1e-10,\n            }\n\n# set vpt2 level options here\noptions = {\"FD\": 'HESSIAN',\n            \"DISP_SIZE\": 0.05,\n            \"QC_PROGRAM\": \"psi4\",\n            \"MULTILEVEL\": True,\n            \"RETURN_PLAN\": True,\n            }\n\ninp = {\"molecule\": mol,\n        \"input_specification\": [{\"model\": qc_model1,\n                                \"keywords\": qc_kwargs},\n                                {\"model\": qc_model2,\n                                \"keywords\": qc_kwargs}],\n        \"keywords\": options}\n\nharmonic_plan = pyvpt2.vpt2_from_schema(inp)\nharmonic_plan.compute(client=client)\nharmonic_ret = harmonic_plan.get_results(client=client)\n\nplan = pyvpt2.vpt2_from_harmonic(harmonic_ret, qc_spec=inp[\"input_specification\"][1], **options)\nplan.compute(client=client)\nret = plan.get_results(client=client)\nresults = pyvpt2.process_vpt2(ret, **options)\n</code></pre></p>"},{"location":"tutorial/#options-list","title":"Options list:","text":"<ul> <li><code>DISP_SIZE</code> (Default: 0.05) Displacement size used in finite-difference calculations.</li> <li><code>FD</code> (Default: \"HESSIAN\") Level of finite-difference calculation. Choose highest analytical derivative available for chosen method. Options: \"ENERGY\", \"GRADIENT\", or \"HESSIAN\"   </li> <li><code>FERMI</code> (Default: True) Deperturb Fermi resonances?</li> <li><code>GVPT2</code> (Default: False) Diagonalize Fermi resonances? Requires <code>FERMI</code> to be enabled.</li> <li><code>FERMI_OMEGA_THRESH</code> (Default: 200) Frequency difference threshold below which to deperturb resonances.</li> <li><code>FERMI_K_THRESH</code> (Default: 1) Coupling threshold above which to depertub resonances.</li> <li><code>RETURN_PLAN</code> (Default: False) Return a plan of tasks to be sent to a QCPortal client?</li> <li><code>VPT2_OMEGA_THRESH</code> (Default: 1) Frequency below which to omit from VPT2 treatment`</li> <li><code>QC_PROGRAM</code> (Default: \"psi4\") QC program to run </li> <li><code>MULTILEVEL</code> (Default: False) Use different levels of theory for harmonic and anharmonic portions</li> <li><code>TASK_CONFIG</code> qcengine task configuration settings</li> </ul>"},{"location":"tutorial/#troubleshooting","title":"Troubleshooting","text":"<p>The most common issue encountered is the numerical stability of the finite-difference third/fourth derivatives. Tight convergence of energies and tight DFT grids are usually required.</p>"}]}